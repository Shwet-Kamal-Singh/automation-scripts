import nmap
import socket
import requests
from concurrent.futures import ThreadPoolExecutor
import ssl
import logging

class VulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.open_ports = []
        self.vulnerabilities = []
        self.setup_logging()

    def setup_logging(self):
        logging.basicConfig(filename='vulnerability_scan.log', level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def scan_ports(self):
        nm = nmap.PortScanner()
        nm.scan(self.target, arguments='-p-')
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                lport = nm[host][proto].keys()
                for port in lport:
                    if nm[host][proto][port]['state'] == 'open':
                        self.open_ports.append(int(port))
        logging.info(f"Open ports: {self.open_ports}")

    def check_ssl_vulnerability(self, port):
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target, port)) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as secure_sock:
                    cert = secure_sock.getpeercert()
                    ssl_version = secure_sock.version()
                    if ssl_version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        self.vulnerabilities.append(f"Weak SSL/TLS version ({ssl_version}) on port {port}")
        except ssl.SSLError as e:
            self.vulnerabilities.append(f"SSL error on port {port}: {str(e)}")
        except Exception as e:
            logging.error(f"Error checking SSL on port {port}: {str(e)}")

    def check_http_vulnerability(self, port):
        try:
            response = requests.get(f"http://{self.target}:{port}", timeout=5)
            server = response.headers.get('Server')
            if server:
                self.vulnerabilities.append(f"Server information disclosure: {server} on port {port}")
            if 'X-Frame-Options' not in response.headers:
                self.vulnerabilities.append(f"Missing X-Frame-Options header on port {port}")
        except requests.RequestException as e:
            logging.error(f"Error checking HTTP on port {port}: {str(e)}")

    def check_ftp_vulnerability(self, port):
        try:
            with socket.create_connection((self.target, port), timeout=5) as sock:
                banner = sock.recv(1024).decode('utf-8').strip()
                if 'FTP' in banner:
                    self.vulnerabilities.append(f"FTP server information disclosure: {banner} on port {port}")
        except Exception as e:
            logging.error(f"Error checking FTP on port {port}: {str(e)}")

    def scan_vulnerabilities(self):
        with ThreadPoolExecutor(max_workers=10) as executor:
            for port in self.open_ports:
                executor.submit(self.check_ssl_vulnerability, port)
                executor.submit(self.check_http_vulnerability, port)
                executor.submit(self.check_ftp_vulnerability, port)

    def run_scan(self):
        logging.info(f"Starting vulnerability scan for {self.target}")
        self.scan_ports()
        self.scan_vulnerabilities()
        self.report_vulnerabilities()

    def report_vulnerabilities(self):
        if self.vulnerabilities:
            logging.warning("Vulnerabilities found:")
            for vuln in self.vulnerabilities:
                logging.warning(vuln)
        else:
            logging.info("No vulnerabilities found.")

def main():
    target = input("Enter the target IP address or hostname: ")
    scanner = VulnerabilityScanner(target)
    scanner.run_scan()

if __name__ == "__main__":
    main()